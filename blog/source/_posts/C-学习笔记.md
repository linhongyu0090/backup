---
title: C++学习笔记
date: 2022-04-17 16:35:33
tags:
---
# C++学习笔记
1. string的length和size都是O（n）
2. nth_element(arr.begin(),arr.begin()+3,arr.end());
O（n）比sort排序快
3. 1s时限内能做的运算次数大约为1e8，根据复杂度来算是否会超时
4. G++在输出double时不能用%lf，要用%f
6. 注意多组拥立时的EOF、初始化，初始化的常数时间也得估计好
6. int表示范围-32769～32767
7. 单精度float，占用4个字节，有效数字范围为7位有效数字，赋值时末尾加个f
8. 双精度double，占用8个字节，有效数字范围为15～16个有效数字
9. 默认情况下，输出一个小数会显示6位有效数字
10. a对应的ASICII码为65，A对应的ASCII码为97
11. 转义字符：
- 反斜杠 \\
- 水平制表符 \t
12. swith语句判断时候只能是整形或字符型，不可以是一个区间
13. 一维数组名的用途：
- 可以统计整个数组在内存的长度
- 可以获取数组在内存中的首地址
14. C++ 0x代表十六进制
15. 二维数组定义事一定要定义列数
16.  二维数组名的用途：
- 可以统计整个数组在内存的长度
- 可以获取数组在内存中的首地址
17. 自己定义的函数写在main函数前面
18. 值传递时，形参发生任何的改变都不会影响实参
19. 函数声明后面有分号，函数定义后面没有
20. 32位操作系统中指针占4个字节，64位操作系统中指针占8个字节
21. 空指针用于给指针变量进行初始化，不可以进行访问，0～255之间的内存编号是系统占用的，因此不可以访问
22. const int*常量指针，指向常量的指针（可以理解为常量的**指针**），指针的指向可以修改，但是指针指向的值不可以修改
23. int* const p 指针常量，指针类型的变量(可以理解为指针的常量)，指针的指向不可以修改，指针指向的值可以修改
24. const int* const p 指针指向的值和指针的指向都不可以修改
25. 初始结构体的方式:
    - struct Student s1;
    - struct Student s2 = {...}
    - 在定义结构体时顺便创建结构体变量
26. 结构体定义时struct关键字不能省略，使用时可以省略
27. 数组作为函数参数，只能是指针传递
28. case语句中不可以定义变量，加了{}后相当于在语句块中定义变量就可以
```c++
case 3:
                {
                    cout << "请输入删除联系人的姓名：" << endl;
                string name;
                cin >> name;
                if(isExist(&abs,name) == -1){
                    cout << "查无此人" << endl;
                }else{
                    cout << "找到此人" << endl;
                }
                }
                break;
```

29. C++程序在运行时，将内存划分为4个区域：
- 代码区：存放函数题的二进制代码，由操作系统进行管理的
- 全局区：存放全局变量和静态变量以及常量
- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
- 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收
30. 变量本质就是内存，申请完内存就是结构体变量了
31. 引用：给变量起别名，数据类型  &别名 = 原名
- 引用必须初始化
- 引用初始化后不可以修改
32. 引用传递，形参会修饰实参
33. 引用做函数的返回值：
- 不要返回局部变量的引用
- 函数的调用可以作为左值
34. 静态变量存放在全局去，全局区上的数据在程序结束后系统释放。
35. 局部变量存放在栈区
36. 引用本质是指针常量
37. 1.需要首先明确的是，形参改变实参这种情况只可能发生在地址传递或引用传递之中。2.“ 防止形参改变实参”的意思是：在函数中可能会对形参的值进行修改，但是我们有时又不想让实参跟着改变，那么就可以用const来修饰形参。
38. 如果某个位置已经又了默认参数，那么从这个位置往后，从左到右都必须有默认值
39. 如果函数声明有默认参数，函数实现就不能有默认参数，声明和实现只能有一个有默认参数
40. 占位参数也可以有默认参数
41. 函数重载（函数名相同，提高复用性）满足条件:
- 同一作用域下
- 函数名称相同
- 函数参数类型不同，或者个数不同，或者顺序不同
**注意：函数的返回值不可以作为函数重载的条件**
42. 函数重载不要默认参数，避免二义性出现
43. c++面向对象的三大特性：封装、继承、多态
44. 通过类来创建一个对象的过程就叫实例化
45. 类的成员一般加m_前缀（member），可以清晰的表示他是一个类的成员
46. 类中的属性和行为统称为成员
- 属性：成员属性，成员变量
- 行为：成员函数，成员方法
47. 三种访问权限：
- 公共权限 public 成员类内可以访问 类外也可以访问
- 保护权限 protected  成员类内可以访问 类外不可以访问 子类可以访问父类的保护内容
- 私有权限 private 成员类内可以访问 类外不可以访问 子类不可以访问父类的保护内容
48. struct和class默认的访问权限不同：
- struct默认权限为公共
- class默认权限为私有
49. 成员属性设置为私有：
- 可以自己控制读写权限
- 对于写权限，我们可以检测数据的有效性
50. 静态成员变量：
- 所有对象共享一份数据
- 在编译阶段分配内存
- 类内声明，类外初始化
51. 静态成员变量不属于有某个对象上，所有成员共享同一份数据,静态成员变量也是有访问权限的，类外访问不到私有的静态成员变量。
52. 静态成员变量有两种访问方式：
- 通过对象进行访问
- 通过类名进行访问
53. 静态成员函数（也有访问权限）:
- 所有对象共享一个函数
- 静态成员函数只能访问静态成员变量,不可访问不静态成员变量，无法区分是那个对象的非静态成员变量
54. 只有非静态成员变量才属于类的对象上,静态成员变量、非静态成员函数和静态成员函数都不属于类的对象上
55. 空对象占用内存空间为1，c++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置，每个空对象也应该有一个独一无二的内存地址
56. **this指针指向被调用的成员函数所属的对象**，this指针是隐含每一个非静态成员函数内的一种指针，this指针不需要定义，直接使用就可以。
57. this指针的用途：
- 当形参和实参相同时，可以用this指针来区分，（解决名称冲突）
- 在类的非静态成员函数中返回对象本身，可以用return *this
58. 如果要返回本体，要用引用的方式进行返回：
```c++
class Person{
public:
    Person(int age){
        this->age = age;
    }
    Person& PersonAddAge(Person& p){
        this->age += p.age;
        return *this;
    }
    int age;
};
```
59. 
```c++
    if(this == NULL) {
            return;
        }
```
60.  常函数：
- 成员函数后加const后我们称这个函数为常函数
- **常函数内不可以修改成员属性**
- 成员属性声明时加关键字mutable，在常函数中可以修改
常对象：
- 声明对象前加const称该对象为常对象
- 常对象只能调用常函数
61. this指针的本质是指针常量，指针的指向不可以修改 
62. 
```c++
     void showPerson()const{
        // this->m_A = 100;
    }
```
this相当于 const Person* const this(常指针常量)，在成员函数后面加const，修饰的是this指向，让指针指向的值也不可以修改.
63. 属性前加mutable，在常函数中可以修改此属性的值
64. 在对象前加const变成常对象，不可以修改对象的属性,常对象只能调用常函数，不可以调用成员函数，因为成员函数可以修改属性
65. 全局函数函数申明加到要访问的类中，前面加上friend访问权限，这样全局函数就可以访问到该类中的private属性和方法
66. 
```c++
 //类外写构造函数
Building::Building(){
    m_SettingRoom = "客厅";
    m_BedRoom = "卧室";
}
//类外写成员函数
void GoodGay::visit(){
    cout << "好基友类正在访问：" << building->m_SettingRoom << endl;
}
在函数名称前加上作用域
```
67. 在要访问的类中加上class声明语句，并且前面加上friend关键字，这个类的private属性和方法就可以被friend类访问
68. 
```c++
class GoodGay{
public:
    GoodGay();

    void visit();//让visit函数可以访问Building中私有成员
    void visit2();//让visit函数不可以访问Building中私有成员

    Building * building;
};

class Building{
friend void GoodGay::visit();
public:
    Building();
public:
    string m_SettingRoom;

private:
    string m_BedRoom;
};
```
69. 
```c++
ostream& operator<<(ostream& out, Person& p){
    cout << "m_A = " << p.m_A << " " << "m_B = " << p.m_B;
    return cout;
}
```
重载左移运算符配合友元可以实现输出自定义数据类型
70. 赋值运算符就是从左往右运算的
71. 函数调用运算符（）重载，由于使用起啦非常类似于函数调用，因此称为仿函数，仿函数非常灵活，没有固定的写法
72. 默认的访问属性为private,保证了数据的安全性 而c语言的结构体中的默认访问属性为pubic
73. 子类和父类同名属性和函数要加上作用域
```c++
cout << s.Base::m_A << endl;
s.Base::func();
```
74. 如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏父类中所有同名成员函数，如果想访问到父类中被隐藏的同名函数，要加作用域
75. cout << "Base下m_A = " << Son::Base::m_A << endl;第一个::代表通过类名的方式访问，第二个::代表访问父类作用域
76. find查找是从左往右，rfind查找是从右往左，find找到字符串后但会查找的第一个字符位置，找不到返回1，replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串
77. at会进行越界检查[]不会
